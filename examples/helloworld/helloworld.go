package main

import (
	"bytes"
	"fmt"

	"github.com/breezewish/go-cacheprogw"
)

func main() {
	proc, err := cacheprogw.Start("<your-cacheprog-binary>")
	if err != nil {
		panic(err)
	}
	defer proc.Close()

	// An ActionID is a cache action key, the hash of a complete description of a
	// repeatable computation (command line, environment variables,
	// input file contents, executable contents).
	//
	// Currently ActionID is fixed to be 32 bytes in order to follow
	// the same length that go/cmd produces.
	var actionID cacheprogw.ActionID
	copy(actionID[:], []byte("my-cache-key-1234567890abcdef"))

	// Note: According to how go/cmd works, the ActionID should be better generated by
	// using the hash of your "action" as below:
	//
	//   h := cacheprogw.NewHash()
	//   h.Write([]byte("open <file>"))
	//   actionID := h.Sum()

	// Put data into cache. A cacheprog is supposed to make sure
	// that data is available at DiskPath locally.
	data := bytes.NewReader([]byte("The result of open <file>"))
	putResult, err := proc.Put(actionID, data)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Stored %d bytes at %s\n", putResult.Size, putResult.DiskPath)

	// Get data from cache. A cacheprog is supposed to make sure
	// that data is available at DiskPath locally.
	getResult, err := proc.Get(actionID)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Retrieved %d bytes from %s\n", getResult.Size, getResult.DiskPath)
}
